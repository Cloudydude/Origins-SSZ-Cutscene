// Set eggman/eggrobo to burned state
//# address-hook(0x07cbce) end(0x07cc10)
function void fn07cbce()
{
	base.fn07cbce()
	if (objA0.update_address == 0x08565e)
	{
		A1 = 0xffffb378
		objA1.base_state = 0x04
	}
}

// Load burned sprite
//# address-hook(0x067cba) end(0x067ccc)
function void fn067cba()
{
	if (global.zone_act == 0x0a01)
		objA0.animation.sprite = 3
	else
		base.fn067cba()
}

// Egg mobile explodes
//# address-hook(0x07cc26) end(0x07cc34)
function void fn07cc26()
{
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		// Eggrobo pops an animal and adds points to your score
		addScore(10) // add 100 points
		if (allocDynamicObjectStd())
		{
			// Spawn floating points display
			objA1.update_address = 0x02cce0
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16
			objA1.animation.sprite = 0x00
		}
		objA1.update_address = 0x01e5e0 // Spawn the small explosion 
	}
	else
	{
		// Eggman falls out of his egg mobile
		if (allocDynamicObjectStd())
		{
			u8[A1 + 0x04] = (render_flag.WORLD)
			objA1.update_address = 0x200070
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16
			objA1.state = 0
			objA1.sprite_attributes = objA0.sprite_attributes
			objA1.velocity.x = 0xD0
			objA1.velocity.y = -0x330
			u16 Easter = System.rand() % 50 // 2% chance
			if (Easter == 1)
				Audio.playAudio("Robotnik_AOSTH", AudioContext.CONTEXT_SOUND)
		}
	}
	base.fn07cc26()
}

//# address-hook(0x200070)
function void Eggmanfalls()
{
	if (objA0.velocity.y >= 0xb28)
	{
		UnloadObject() // despawn falling eggman
		return
	}

	objA0.box_size.y = 40
	objA0.position.x += objA0.velocity.x
	UpdateMovementSimple()
	DrawObject() // spawn falling eggman
}

// escaping the claw
//# address-hook(0x07cc3a) end(0x07cc62)
function void fn07cc3a()
{
	base.fn07cc3a()

	if (u8[0xffffe654] != 0)
	{
		XtraEscape()
		return
	}

	if (isMainCharacter(CHARACTER_KNUCKLES))
		return

	SonicTailsEscaping()
}

function void XtraEscape()
{
	if (!isMainCharacter(CHARACTER_KNUCKLES))
		SonicTailsEscaping()
}

function void SonicTailsEscaping()
{
	A1 = 0xffffb000
	// objA0.position.x.u16 = objA1.position.x.u16
	// objA0.position.y.u16 = objA1.position.y.u16
	// objA0.velocity.x = 0x0400
	objA0.velocity.y = (isMainCharacter(CHARACTER_SONIC)) ? 0x320 : 0x1e0 // (isMainCharacter(CHARACTER_TAILS))
	
	if (isMainCharacter(CHARACTER_SONIC))
	{
		Audio.playAudio("dropdash_charge", AudioContext.CONTEXT_SOUND)
		u8[A1 + 0x20] = char.state.SONIC_DROPDASH
	}
	else //(isMainCharacter(CHARACTER_TAILS))
	{
		playSound(0xba)
		objA1.animation.sprite = 0xa0
		u8[A1 + 0x20] = char.state.TAILS_FLYDOWN
	}
}

function bool skipPart()
{
	A1 = 0xffffb000

	bool skip = false
	D0.u16 = objA0.position.x.u16
	if (D0.u16 > 0x08)
	{
		D1.u16 = objA1.position.x.u16
		if (D1.u16 < D0.u16 - 0x0c)
		{
			skip = true
		}
		else if (D1.u16 >= D0.u16 + 0x0c)
		{
			skip = true
		}
	}
	return skip
}

function void XtraInClaw()
{
	if (!isMainCharacter(CHARACTER_KNUCKLES))
		SonicTailsInClaw()
}

function void SonicTailsInClaw()
{
	u8[A1 + 0x20] = char.state.LIFTED
	objA1.animation.sprite = (isMainCharacter(CHARACTER_TAILS)) ? 0xb6 : 0xc9
}

// In the claw
//# address-hook(0x07cd82) end(0x07ce18)
function void fn07cd82()
{
	base.fn07cd82()

	if (!skipPart())
	{
		A1 = 0xffffb000

		if (u8[0xffffe654] != 0)
		{
			XtraInClaw()
			return
		}


		if (isMainCharacter(CHARACTER_KNUCKLES))
			return

		SonicTailsInClaw()
	}
}

global bool Fixit
// Character position in claw
//# address-hook(0x07ce42) end(0x07ce66)
function void fn07ce42()
{
	base.fn07ce42()
	
	Fixit = true
	// Have the hud scroll out instead of disappearing
	if (global.level_started >= -104)
		global.level_started -= 15
	else if (global.level_started < -104)
		global.level_started = -119

	if (u8[0xffffe654] != 0)
	{
		XtraClawcords()
		return
	}

	if (isMainCharacter(CHARACTER_KNUCKLES))
		return

	SonicTailsClaw()
}

function void SonicTailsClaw()
{
    if ((u8[0xfffffab8] & 0x20) == 0)
    {
        u8 adjust = (isMainCharacter(CHARACTER_TAILS)) ? 1 : 3
        A1 = 0xffffb000
        objA1.position.x.u16 -= adjust
        objA1.position.y.u16 -= 6
    }
}

function void XtraClawcords()
{
    if (!isMainCharacter(CHARACTER_KNUCKLES))
        SonicTailsClaw()
}

function bool XtraOnGround()
{
	if (isMainCharacter(CHARACTER_KNUCKLES))
		return false
	SonicTailsGround()
	return true
}

function void SonicTailsGround()
{
	UpdateMovementStraightSimple()
	A1 = 0xffffb000
	objA1.position.x.u16 = objA0.position.x.u16
	objA1.position.y.u16 = objA0.position.y.u16
	D0.u16 = objA0.position.x.u16
	
	
	CheckGroundCollision()
	if (isMainCharacter(CHARACTER_SONIC))
	{
		if (D1.u16 <= 14)
		{

			u8[0xffffb000 + 0x2e] = 0
			StopObjectA1()


			if (u8[0xffffb000 + 0x20] != char.state.ROLLING)
			{
				Audio.playAudio("dropdash_release", AudioContext.CONTEXT_SOUND)
				// drop dash dust
				u8[A6 + 0x20] = 0x02
				u16[A6 + 0x10] = u16[0xffffb000 + 0x10]
				u16[A6 + 0x14] = (0x4AC)
				u8[A6 + 0x23] = 0x01
				u8[A6 + 0x2a] = char.flags & char.flag.FACING_LEFT
				u8[0xffffb000 + 0x22] = 0x96 // first rolling frame
			}
			// char.groundspeed
			s16[0xffffb000 + 0x1c] = objA0.velocity.x = 0x0800
			objA0.velocity.y = 0
			u16[0xffffb000 + 0x14] = 0x4b1 // char.position.y
			player1.control_override = 0xff // Disable P1's controls

			u8[0xffffb000 + 0x20] = char.state.ROLLING // char.state
			u8[0xffffb000 + 0x2a] |= char.flag.ROLLING // char.flags
		}
	}
	else // (isMainCharacter(CHARACTER_TAILS))
	{
		if (D1.u16 <= 9)
		{
			u8[0xffffb000 + 0x2e] = 0
			StopObjectA1()
			
			u16[0xffffb000 + 0x14] = 0x4b0
			s16[0xffffb000 + 0x1c] = objA0.velocity.x
			objA0.velocity.y = 0
			player1.control_override = 0xff // Disable P1's controls
			control.player1 = 0x0808 // Make the character walk to the right
		}
	}

	if (D0.u16 < level.bossarea.right)
		return
	
	player1.control_override = 0 // Player regains control of character

	if (isMainCharacter(CHARACTER_TAILS))
		s16[0xffffb000 + 0x1c] = 0 // Set Tails' ground speed back to 0

	objA0.update_address = 0x07ccb0
	objA0.countdown_value = 0x06
	objA0.velocity.x = 0
	objA0.velocity.y = 0
	objA0.hitbox_extends.y = (isMainCharacter(CHARACTER_TAILS)) ? 0x10 : 0x0e
}

// On the ground
//# address-hook(0x07cc68) end(0x07ccaa)
function void fn07cc68()
{
	Fixit = false
	if (u8[0xffffe654] != 0)
	{
		if (XtraOnGround())
		{
			Hudflysin()
			return
		}
	}

	if (isMainCharacter(CHARACTER_KNUCKLES))
		base.fn07cc68()
	else
		SonicTailsGround()

	Hudflysin()
}

function void Hudflysin()
{
	if (D0.u16 < level.bossarea.right)
		return
	global.level_started = -0x6f // let hud fly in
}

global bool Egg.Glasses

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{

	if (objA0.update_address == 0x200070)
	{
		// if modded sprites not detected, use the default sprites
		u8 animationSpriteEx = ((global.framecounter >> 2) & 0x03)
		u64 key = stringformat("eggman-modded-0%d", animationSpriteEx)
		if (!Renderer.hasCustomSprite(key))
		{
			u64 eggs = (Egg.Glasses) ? "blue_glasses" : "black"
			key = stringformat("eggman-%s-0%d", eggs, animationSpriteEx)
		}

		Renderer.drawCustomSprite(key, px, py, 0, SPRITE_FLAG_PRIO, renderQueue)
		return true
	}
	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}

// Fix for Mecha Sonic so that he doesn't go into the great beyond
//# address-hook(0x07c144) end(0x07c156)
function void fn07c144()
{
	base.fn07c144()
	if !(isMainCharacter(CHARACTER_KNUCKLES) && u8[0xffffe654] == 0)
	{
		if (objA0.base_state == 0x1e)
			objA0.hitbox_extends.y = 0x1f
	}
}

//# address-hook(0x00db44) end(0x00dbb2)
function void RenderHUD()
{
	if (!Fixit)
	{
		base.RenderHUD()
		return
	}
#if STANDALONE
	if (DEBUG_DISABLE_HUD)
		return
#endif

	s16 baseX = global.level_started
	if (baseX < 0)
	{
		baseX += 8
		global.level_started = baseX
	}
	baseX += 0x0f
	s16 baseY = 0x08
	u16 renderQueue = 0xe000

	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)
#if STANDALONE
	if (!debug_mode.state)
	{
		if (!isBonusStage)
		{
			// Score
			HUD.drawSprite("hud_text_score", baseX, baseY, renderQueue)
			++renderQueue
			HUD.drawNumber("hud_digit_%d", player.score * 10, baseX + 0x58, baseY, renderQueue)
			++renderQueue

			// Time
			{
				bool show = (timer.minutes < 9 || isBonusStage || (level.framecounter & 0x08) || Game.getSetting(SETTING_INFINITE_TIME))
				HUD.drawSprite(show ? "hud_text_time" : "hud_text_time_red", baseX, baseY + 0x10, renderQueue)
				++renderQueue

				// Unfortunately, the time progress is done later inside the frame, so we don't have the right value in "timer.frames" yet
				//  -> If the conditions for time progress are met, add one and everything will be alright
				u16 minutes = timer.minutes
				u16 seconds = timer.seconds
				u16 frames = timer.frames
				if (hud.dirty.timer && !global.game.paused && timer.alldata < 0x93b3b)	// That is 9:59 and 59 frames
				{
					++frames
					seconds += (frames / 60)
					minutes += (seconds / 60)
					frames %= 60
					seconds %= 60
				}
				u16 centiseconds = (frames * 99 + 30) / 59

				u16 px = (minutes >= 10) ? (baseX + 8) : baseX
				if (Game.getSetting(SETTING_EXTENDED_HUD))
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_minutes", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_seconds", px + 0x48, baseY + 0x10, renderQueue)
					HUD.drawDigit(centiseconds / 10, px + 0x50, baseY + 0x10, renderQueue)
					if (minutes < 10)
						HUD.drawDigit(centiseconds % 10, px + 0x58, baseY + 0x10, renderQueue)
				}
				else
				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_colon", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
				}
				++renderQueue
			}
		}

		// Rings
		{
			u16 py = (isBonusStage) ? baseY : baseY + 0x20
			bool show = (ring_counter != 0 || (level.framecounter & 0x08))
			HUD.drawSprite(show ? "hud_text_rings" : "hud_text_rings_red", baseX, py, renderQueue)
			++renderQueue

			u16 px = baseX + (!isBonusStage && Game.getSetting(SETTING_EXTENDED_HUD) ? 0x58 : 0x40)
			for (u32 value = ring_counter;;)
			{
				HUD.drawDigit(value % 10, px, py, renderQueue)
				px -= 8
				value /= 10
				if (value == 0)
					break
			}
			++renderQueue
		}

		// Lives (not visible in Time Attack or with infinite lives setting)
		if (!Game.isTimeAttack() && !Game.getSetting(SETTING_INFINITE_LIVES))
		{
			bool useMobilePosition = HUD.useMobileLivesDisplay()
			u16 px = useMobilePosition ? (getScreenWidth() - baseX - 0x30) : baseX
			u16 py = useMobilePosition ? baseY : 200

			HUD.drawSprite(getCharacterLivesIcon(getMainCharacter()), px, py, renderQueue)
			++renderQueue

			if (lives_counter >= 10)
				HUD.drawSmallDigit(u16((lives_counter / 10) % 10), px + 0x20, py + 8, renderQueue)
			HUD.drawSmallDigit(u16(lives_counter % 10), px + 0x28, py + 8, renderQueue)
		}
	}
	else
#endif
	{
		D4 = (isBonusStage) ? 8 : 0

		if ((level.framecounter & 0x08) == 0)
		{
			if (ring_counter == 0)
			{
				D4 += 2		// Set rings HUD text to flicker
			}
			if (timer.minutes == 9 && !isBonusStage)
			{
				D4 += 4		// Set timer HUD text to flicker
			}
		}

		// Targets:
		//  - 0x00dbc2	-> D4.u16 = 0x00		// Complete HUD text
		//  - 0x00dc00	-> D4.u16 = 0x02		// HUD with rings text flickering
		//  - 0x00dc32	-> D4.u16 = 0x04		// HUD with time text flickering
		//  - 0x00dc6a	-> D4.u16 = 0x06		// HUD with both rings and time flickering
		//  - 0x00dc96	-> D4.u16 = 0x08		// Bonus stage HUD
		//  - 0x00dcb6	-> D4.u16 = 0x0a		// Bonus stage HUD with rings text flickering
		A1 = tableLookupAddress(0x00dbb6, D4.u16)

		D4.s16 = u16[A1] - 1
		D0.s16 = baseX + 0x80
		D1.u16 = 0x0108
		D5.u16 = 0x86ca
		A1 += 2
		if (D4.s16 >= 0)
		{
			writeToSpriteTable(renderQueue)
		}
	}
}

function void ClearPatternLoadingQueue()
{
	Fixit = false
	base.ClearPatternLoadingQueue()
}
